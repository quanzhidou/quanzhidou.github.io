<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Ananke</title>
    <link>https://quanzhidou.github.io/tags/leetcode/</link>
    <description>Recent content in Leetcode on Ananke</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Jun 2022 00:15:24 +0800</lastBuildDate><atom:link href="https://quanzhidou.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>豆豆的刷题日记（5）</title>
      <link>https://quanzhidou.github.io/post/chapter-13/</link>
      <pubDate>Mon, 20 Jun 2022 00:15:24 +0800</pubDate>
      
      <guid>https://quanzhidou.github.io/post/chapter-13/</guid>
      <description>豆豆的刷题日记（5）——快慢指针秒杀数组问题 leetcode 26题删除有序数组中的重复项
思路 直接使用快慢指针技巧，让fast指针走在前面，slow指针走在后面，因为是有序数组，所以重复项一定是连续的，所以只需要找到不重复项并赋值给nums[slow]即可，也就是说当nums[slow] != nums[fast]就将nums[fast]赋值给nums[slow]，最后返回不重复数组的长度即slow+1即可
go语言代码 func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } slow := 0 for fast := 0; fast &amp;lt; len(nums); fast++ { if nums[slow] != nums[fast] { slow++ nums[slow] = nums[fast] } } return slow } 踩得坑 一开始以为返回的是数组最后元素的下标，没想到是返回数组的长度，看了好久。。。。</description>
    </item>
    
    <item>
      <title>豆豆的刷题日记（4）</title>
      <link>https://quanzhidou.github.io/post/chapter-12/</link>
      <pubDate>Sun, 19 Jun 2022 02:04:33 +0800</pubDate>
      
      <guid>https://quanzhidou.github.io/post/chapter-12/</guid>
      <description>豆豆的刷题日记（4） 递归的魔力（4）——反转链表最终版 leetcode 234题回文链表
不多废话直接上思路
第一步：找到中间节点主要思想为快慢指针 使用快慢指针这里会有一个问题，链表节点个数可能是奇数个也可能是偶数个，判断的方式就是fast节点最后的值是否为nil，如果fast节点最终的值是nil，证明链表节点为偶数个，如果不为空，则为奇数个节点，在这种情况下，slow指针还需要在走一步
第二步：将以中间节点为头指针的链表反转 还是之前反转链表的思想，第一个变量pre记录当前节点的前驱节点，cur记录当前节点，next记录当前节点的下一个节点，最后返回反转后的头节点
第三步：遍历这两个链表判断是否是回文链表 go语言代码
func findMid(head *ListNode) *ListNode { slow := head fast := head for fast != nil &amp;amp;&amp;amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next } if fast != nil { slow = slow.Next } return slow } func reverse(head *ListNode) *ListNode { var pre *ListNode cur := head next := head for cur != nil { next = cur.</description>
    </item>
    
    <item>
      <title>豆豆的刷题日记（3）</title>
      <link>https://quanzhidou.github.io/post/chapter-11/</link>
      <pubDate>Sat, 18 Jun 2022 21:36:24 +0800</pubDate>
      
      <guid>https://quanzhidou.github.io/post/chapter-11/</guid>
      <description>豆豆的刷题日记（3） 递归的魔力（2）——反转链表进阶 leetcode 25题 K 个一组翻转链表
分析 首先看函数定义reverseKGroup(head *ListNode, k int) *ListNode，其意义为将以head为头节点的链表按k个一组反转，最后返回反转后的头节点
首先来看返回的新的头节点，以reverseKGroup(head, 2)为例
如图所示，返回的新的头节点为newHead为第二个节点，也就是函数定义中的k参数，而将各个k区间反转后的链表连接起来还需要一个将head节点与第k + 1个节点相连的过程，这时我们需要一个将区间[left, right）的链表部分反转的函数
反转区间[left, right）的链表 首先是函数签名，这个函数应该要有两个形参，分别代表left和right，函数定义reverseSection(left *ListNode, right *ListNode) *ListNode，函数内需要三个变量，第一个变量pre记录当前节点的前驱节点，cur记录当前节点，next记录当前节点的下一个节点
go语言代码 func reverseSection(left *ListNode, right *ListNode) *ListNode{ var pre *ListNode cur := left next := left for cur != right{ next = cur.Next cur.Next = pre pre = cur cur = next } return pre } K 个一组翻转链表 go语言代码 func reverseKGroup(head *ListNode, k int) *ListNode { if head == nil{ return nil } left := head right := head for i := 0; i &amp;lt; k; i++{ //当最后不够k个一组时，不反转链表 if right == nil{ return head } right = right.</description>
    </item>
    
    <item>
      <title>豆豆的刷题日记（2）</title>
      <link>https://quanzhidou.github.io/post/chapter-10/</link>
      <pubDate>Sat, 18 Jun 2022 15:03:05 +0800</pubDate>
      
      <guid>https://quanzhidou.github.io/post/chapter-10/</guid>
      <description>豆豆的刷题日记（2） 递归的魔力（2）——反转链表进阶 反转链表前 N 个节点 思路和反转整个链表差不多，但需要稍微修改一下
反转整个链表代码
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } res := reverseList(head.Next) head.Next.Next = head head.Next = nil return res } 如图，需要修改的地方有返回的节点不同，不是最后一个节点，所以要记录一下后驱节点
在反转整个链表的时候，最后直接将head.Next置为空，是因为将整个链表反转之后，原来的头节点就变成了最后一个节点，所以可以直接置为空，现在head节点反转后不一定时最后一个节点，所以要将head.Next设置为后驱节点
go语言代码 var successor *ListNode func reverseN(head *ListNode, n int) *ListNode { if n == 1{ successor = head.Next return head } last := reverseN(head.Next, n - 1) head.Next.Next = head head.Next = successor return last } 反转一段区间内的链表 leetcode 92题反转链表Ⅱ</description>
    </item>
    
    <item>
      <title>豆豆的刷题日记（1）</title>
      <link>https://quanzhidou.github.io/post/chapter-8/</link>
      <pubDate>Thu, 16 Jun 2022 20:18:18 +0800</pubDate>
      
      <guid>https://quanzhidou.github.io/post/chapter-8/</guid>
      <description>递归的魔力（1）——leetcode__206反转链表 leetcode-206 反转链表
第一步：明确函数定义，reverseList(head *ListNode) *ListNode，这个reverseList函数的定义为：将头节点为head的链表反转，返回链表反转后的头节点
第二步：明确递归的终点：递归的终点就是当节点head为nil或者head.next为nil时返回head
第三步：开始递归：last := reverseList(head.Next)
如图所示，第三步的程序的意思就是将以2为头节点的链表反转，执行完毕后如图
第四步，执行完第三步的代码后，链表结构变成上图所示，然后将head.next节点指向head即可， head.Next.Next = head
第五步，将head节点的next置为空，返回原链表的末尾节点last
go语言代码 func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } res := reverseList(head.Next) head.Next.Next = head head.Next = nil return res } </description>
    </item>
    
  </channel>
</rss>
